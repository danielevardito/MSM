module MSMDiGraph

  use set.Fset
  use int.Int
  use list.List
  use list.Length
  use list.Mem as LM
  use list.Map as LMap

  type snippet
  type metadata

  type v = S snippet | M metadata
  type e = (v,v)

  let function src (e: e) : v = let (u,_) = e in u
  let function dst (e: e) : v = let (_,u) = e in u

  clone digraph.DiGraph with
    type v = v,
    type e = e,
    val src = src,
    val dst = dst,
    axiom .

  let predicate is_metadata (v: v) =
    match v with
    | M _ -> true
    | S _ -> false
    end

  let predicate is_snippet (v: v) =
    match v with
    | M _ -> false
    | S _ -> true
    end
  
  val function metadata_indegree (v: v) (g: graph) : int
    requires  { is_metadata v }
    ensures   { result = cardinal (Fset.filter g.edges (fun (p: e) -> dst p = v /\ is_metadata (src p))) }

  val function metadata_outdegree (v: v) (g: graph) : int
    requires  { is_metadata v }
    ensures   { result = cardinal (Fset.filter g.edges (fun (p: e) -> src p = v /\ is_metadata (dst p))) }

  val function snippet_metadata_outdegree (v: v) (g: graph) : int
    requires  { is_snippet v }
    ensures   { result = cardinal (Fset.filter g.edges (fun (p: e) -> src p = v /\ is_metadata (dst p))) }

  val function snippet_metadata_indegree (v: v) (g: graph) : int
    requires  { is_metadata v }
    ensures   { result = cardinal (Fset.filter g.edges (fun (p: e) -> dst p = v /\ is_snippet (src p))) }

  axiom metadata_metadata_valid_relations:
    forall g: graph, v: v. memv v g /\ is_metadata v 
      -> 0 <= metadata_indegree v g <= 1 /\ 0 <= metadata_outdegree v g 
  axiom valid_metadatasrc_edges:
    forall g: graph, e: e. meme e g ->
      is_metadata (src e) -> is_metadata (dst e) 
  axiom valid_snippetsrc_edges:
    forall g: graph, e:e. meme e g ->
      is_snippet (src e) -> is_metadata (dst e)
  axiom no_self_loops:
    forall g: graph, e: e. meme e g -> src e <> dst e
  axiom minimum_metadata:
    forall g: graph, s: v. is_snippet s /\ memv s g /\ 
      (exists m: v. is_metadata m /\ memv m g) -> 
        exists m: v. is_metadata m /\ meme (s,m) g
  
  axiom metadata_outdegree_eq: (* secondary axiom, should be lemma *)
    forall g: graph, m: v. memv m g /\ is_metadata m -> metadata_outdegree m g = outdegree m g

  lemma metadata_src_implies_dst:
    forall g: graph, e: e, m: v.
      meme e g /\ src e = m /\ is_metadata m -> is_metadata (dst e)

  lemma metadata_out_eq:
    forall g: graph, m: v. 
      let out_set_m = Fset.filter g.edges (fun (p: e) -> src p = m /\ is_metadata (dst p)) in
      let out_set = Fset.filter g.edges (fun (p: e) -> src p = m) in
      (forall e: e. mem e out_set_m <-> mem e out_set) ->
      out_set_m = out_set

  lemma metadata_indegree_le_cardinale:
    forall v: v, g: graph. memv v g /\ is_metadata v
      -> 0 <= metadata_indegree v g <= cardinale g

  axiom metadata_indegree_le_indegree: (* should be lemma *)
    forall g: graph, v: v. memv v g /\ is_metadata v -> metadata_indegree v g <= indegree v g
  
  lemma metadata_outdegree_le_cardinale:
    forall v: v, g: graph. is_metadata v /\ memv v g
      -> 0 <= metadata_outdegree v g <= cardinale g

  lemma metadata_outdegree_le_outdegree:
    forall g: graph, v: v. memv v g /\ is_metadata v -> metadata_outdegree v g <= outdegree v g
    
  lemma snippet_metadata_outdegree_le_cardinale:
    forall v: v, g: graph. is_snippet v /\ memv v g
      -> 0 <= snippet_metadata_outdegree v g <= cardinale g

  lemma not_metadata_to_snippet:
    forall g: graph, e: e. meme e g -> (is_metadata (src e) -> not (is_snippet (dst e)))

  let function insert_freemetadata (m: v) (g: graph) : graph
    requires  { is_metadata m }
    requires  { not (memv m g) }
    ensures   { result = insertv m g }
  = insertv m g 

  let function insert_metadata (m p: v) (g: graph) : graph
    requires  { is_metadata m /\ is_metadata p }
    requires  { not (memv m g) /\ memv p g } 
    ensures   { result.vertices = Fset.add m g.vertices }
    ensures   { result.edges = Fset.add (p,m) g.edges }
  = let g_with_m = insert_freemetadata m g in
    inserte (p,m) g_with_m 

  lemma insert_metadata_cardinal_edges_vertices:
    forall g1 g2: graph, m p: v. is_metadata m /\ is_metadata p /\ not (memv m g1) /\ memv p g1 /\ g2 = insert_metadata m p g1
      -> cardinalv g2 = cardinalv g1 + 1 /\ cardinale g2 = cardinale g1 + 1

  lemma insert_metadata_meme:
    forall g1 g2: graph, m p: v. is_metadata m /\ is_metadata p /\ not (memv m g1) /\ memv p g1 /\ g2 = insert_metadata m p g1
      -> meme (p,m) g2

  let rec function insert_metadata_list_for_snippet (s: v) (metadata_list: list v) (g: graph) : graph
    requires  { is_snippet s }
    requires  { memv s g }
    requires  { forall m: v. LM.mem m metadata_list -> is_metadata m /\ memv m g }
    ensures   { result.vertices = g.vertices }
    ensures   { forall e: e. meme e g -> meme e result }
    ensures   { forall m: v. LM.mem m metadata_list -> meme (s,m) result }
    ensures   { forall m r. metadata_list = Cons m r -> meme (s,m) result }
    ensures   { metadata_list = Nil -> (exists m: v. is_metadata m /\ memv m g /\ meme (s,m) result) }
  = match metadata_list with
    | Nil -> g
    | Cons m l ->  
        let g_sm_edge = inserte (s,m) g in
        assert { g.vertices = g_sm_edge.vertices };
        insert_metadata_list_for_snippet s l g_sm_edge
    end

  let function insert_snippet (s: v) (metadata_list: list v) (g: graph) : graph
    requires  { is_snippet s }
    requires  { not (memv s g)}
    requires  { metadata_list <> Nil } (* MODIFICA: Lista non vuota *)
    requires  { forall m: v. LM.mem m metadata_list -> is_metadata m /\ memv m g }
    ensures   { result.vertices = Fset.add s g.vertices }
    ensures   { forall e: e. meme e g -> meme e result }
    ensures   { forall m: v. LM.mem m metadata_list -> meme (s,m) result }
    ensures   { snippet_metadata_outdegree s result > 0 }
  = let g_s_inserted = insertv s g in
    insert_metadata_list_for_snippet s metadata_list g_s_inserted

  lemma insert_snippet_cardinal_edges:
    forall g: graph, s: v, metadata_list: list v. 
      is_snippet s /\ not (memv s g) /\ metadata_list <> Nil /\ 
      (forall m: v. LM.mem m metadata_list -> is_metadata m /\ memv m g) ->
        let g_inserted = insert_snippet s metadata_list g in
          cardinale g_inserted = cardinale g + length metadata_list

  let function get_all_metadata_from_snippet (s: v) (g: graph) : list v
    requires  { is_snippet s /\ memv s g }
    ensures   { forall m: v. LM.mem m result /\ is_metadata m /\ memv m g <-> meme (s,m) g }
  = successors_list s g

  let function get_snippet (s: v) (g: graph) : (snippet: v, metadata_list: list v)
    requires  { is_snippet s /\ memv s g  }
    ensures   { s = snippet /\ metadata_list = (get_all_metadata_from_snippet s g) }
  = s, (get_all_metadata_from_snippet s g)

  let rec function filter_snippets_from_vertices (l: list v) : list v
    ensures { forall s: v. LM.mem s result <-> is_snippet s /\ LM.mem s l }
    ensures { length result <= length l }
    ensures { forall s: v. LM.mem s result -> is_snippet s }
  = match l with
    | Nil -> Nil
    | Cons x r -> if (is_snippet x) then Cons x (filter_snippets_from_vertices r) else (filter_snippets_from_vertices r)
    end

  let rec function get_snippets_with_metadata_from_list (l: list v) (g: graph) : list (v, list v)
    requires { forall s: v. LM.mem s l -> is_snippet s /\ memv s g }
    ensures  { forall s: v, ml: list v. LM.mem (s,ml) result -> (s,ml) = get_snippet s g }
  = match l with
    | Nil -> Nil
    | Cons s r -> Cons (get_snippet s g) (get_snippets_with_metadata_from_list r g)
    end

  let function get_all_snippets (g: graph) : list (v, list v)
    ensures { forall s: v, ml: list v.
                is_snippet s /\ memv s g /\ ml = get_all_metadata_from_snippet s g -> LM.mem (s, ml) result }
  = let all_snippets = filter_snippets_from_vertices (vertices_list g) in
    let all_snippets_with_metadata = get_snippets_with_metadata_from_list all_snippets g in
    all_snippets_with_metadata

  let function get_snippets_from_metadata (m: v) (g: graph) : fset v
    requires  { is_metadata m }
    ensures   { forall s: v. mem s result <-> memv s g /\ is_snippet s /\ meme (s,m) g }
  = let pred = predecessors_list m g in
    list_to_fset (filter_snippets_from_vertices pred)

  let rec ghost function get_snippets_union (metadata_list: list v) (g: graph) : fset v 
    requires  { forall m: v. LM.mem m metadata_list -> is_metadata m }
    ensures   { forall m: v. LM.mem m metadata_list -> Fset.subset (get_snippets_from_metadata m g) result }
  = match metadata_list with
    | Nil -> Fset.empty 
    | Cons m r -> Fset.union (get_snippets_from_metadata m g) (get_snippets_union r g)
    end
  
  let ghost function get_snippets_union_list (metadata_list: list v) (g: graph) : list v
    requires  { forall m: v. LM.mem m metadata_list -> is_metadata m }
  = fset_to_list (get_snippets_union metadata_list g)

  let rec ghost function get_snippets_intersection (metadata_list: list v) (g: graph) : fset v
    requires  { forall m: v. LM.mem m metadata_list -> is_metadata m }
    ensures   { forall m: v. LM.mem m metadata_list -> Fset.subset result (get_snippets_from_metadata m g) }
  = match metadata_list with
    | Nil -> Fset.empty
    | Cons m Nil -> get_snippets_from_metadata m g
    | Cons m r -> Fset.inter (get_snippets_from_metadata m g) (get_snippets_intersection r g)
    end

  let ghost function get_snippets_intersection_list (metadata_list: list v) (g: graph) : list v
    requires  { forall m: v. LM.mem m metadata_list -> is_metadata m }
  = fset_to_list (get_snippets_intersection metadata_list g)

  let function delete_snippet (s: v) (g: graph) : graph
    requires  { is_snippet s /\ memv s g }
    ensures   { forall x: v. x <> s -> memv x g <-> memv x result }
    ensures   { forall m: v. not (meme (s,m) result) }
    ensures   { forall m x: v. is_snippet x -> x <> s -> (meme (x,m) g <-> meme (x,m) result) }
  = deletev s g

  lemma snippet_not_mem:
    forall s: v, g1 g2: graph. is_snippet s /\ memv s g1 /\ g2 = delete_snippet s g1 -> not (memv s g2)

  let function only_metadata_of_snippet (m s: v) (g: graph) : bool 
    ensures { result = is_metadata m /\ is_snippet s /\ memv m g /\ memv s g -> snippet_metadata_outdegree s g = 1 /\ meme (s,m) g }
  = if is_metadata m && is_snippet s && memv m g && memv s g then 
      (snippet_metadata_outdegree s g = 1 && meme (s,m) g)
    else true 

  lemma no_edges_deletev:
    forall m s: v, g1 g2: graph.  
      is_snippet s /\ is_metadata m /\ 
      memv m g1 /\ memv s g1 /\
      meme (s,m) g1 /\ g2 = deletev s g1
        -> not (memv s g2) /\ not (meme (s,m) g2)

  let rec function delete_snippets_with_only_m (m: v) (snippets: list v) (g: graph) : graph
    requires  { is_metadata m /\ memv m g }
    ensures   { forall s: v. LM.mem s snippets /\ only_metadata_of_snippet m s g -> not (memv s result) /\ not (meme (s,m) result) }
    ensures   { forall s: v. LM.mem s snippets /\ not (only_metadata_of_snippet m s g) -> memv s result }
    ensures   { forall x: v. is_metadata x -> memv x g <-> memv x result }
  = match snippets with
    | Nil -> g
    | Cons s r -> 
        let rec_g = delete_snippets_with_only_m m r g in
        if only_metadata_of_snippet m s g then delete_snippet s (rec_g) else rec_g 
    end

  let function delete_metadata (m: v) (g: graph) : graph
    requires  { is_metadata m /\ memv m g }
    ensures   { not (memv m result )}
    ensures   { forall s: v. only_metadata_of_snippet m s g -> not (memv s result) /\ not (meme (s,m) result) }
    ensures   { forall s: v. not (only_metadata_of_snippet m s g) -> memv s result }
    ensures   { forall x: v. is_metadata x -> x <> m -> memv x g <-> memv x result }
  = let snippets = get_snippets_from_metadata m g in
    let g_no_snippets = delete_snippets_with_only_m m (fset_to_list snippets) g in
    deletev m g_no_snippets

  predicate is_root (m: v) (g: graph) = forall n: v. is_metadata n /\ memv n g -> not (meme (n,m) g)

  let rec function filter_metadata_parents (m_list: list v) (g: graph) : list v
    requires  { forall m: v. LM.mem m m_list -> LM.mem m (vertices_list g) }
    ensures   { forall m: v. LM.mem m result <-> is_root m g /\ LM.mem m m_list } 
    ensures   { forall m: v. LM.mem m m_list /\ is_metadata m -> LM.mem m result }
  = match m_list with
    | Nil -> Nil
    | Cons m r -> if is_metadata m && (metadata_indegree m g) = 0 
                    then Cons m (filter_metadata_parents r g)
                    else (filter_metadata_parents r g)
    end

  let function get_all_roots (g: graph) : list v 
    ensures { forall m: v. memv m g /\ is_metadata m /\ is_root m g  <-> LM.mem m result }
  = filter_metadata_parents (vertices_list g) g

  use list.Append

  inductive metadata_path v (list v) v graph =
  | Path_empty:
      forall x: v, g: graph. is_metadata x /\ memv x g -> metadata_path x Nil x g
  | Path_cons:
      forall x y z: v, l: list v, g: graph. 
        is_metadata x /\ is_metadata y /\ is_metadata z /\
        memv x g /\ memv y g /\ memv z g ->
        meme (x,y) g -> metadata_path y l z g -> metadata_path x (Cons x l) z g

  lemma path_right_extension:
    forall x y z: v, l: list v, g: graph. is_metadata x /\ is_metadata y /\ is_metadata z 
      -> metadata_path x l y g -> meme (y,z) g -> metadata_path x (l ++ Cons y Nil) z g

  lemma metadata_path_right_inversion:
    forall x z: v, l: list v, g: graph.
      is_metadata x /\ is_metadata z ->
      metadata_path x l z g ->
        (x = z /\ l = Nil)
    \/ (exists y: v, l': list v.
          is_metadata y /\
          metadata_path x l' y g /\ meme (y,z) g /\ l = l' ++ Cons y Nil)

  lemma metadata_path_trans_helper:
    forall x y z: v, l1 l2_tail: list v, g: graph, y_succ: v.
      is_metadata x /\ is_metadata y /\ is_metadata z /\ is_metadata y_succ ->
      metadata_path x l1 y g ->
      meme (y, y_succ) g ->
      metadata_path y_succ l2_tail z g ->
      metadata_path x (l1 ++ (Cons y l2_tail)) z g

  lemma metadata_path_trans:
    forall x y z: v, l1 l2: list v, g: graph.
      is_metadata x /\ is_metadata y /\ is_metadata z ->
      metadata_path x l1 y g -> metadata_path y l2 z g -> metadata_path x (l1 ++ l2) z g

  lemma metadata_empty_path:
    forall x y: v, g: graph.
      is_metadata x /\ is_metadata y ->
      metadata_path x Nil y g -> x = y

  lemma metadata_path_decomposition:
    forall x y z: v, l1 l2: list v, g: graph.
      is_metadata x /\ is_metadata y /\ is_metadata z ->
      metadata_path x (l1 ++ Cons y l2) z g ->
        metadata_path x l1 y g /\ metadata_path y (Cons y l2) z g 

  let rec function filter_metadata (m_list: list v) (g: graph) : list v
    requires  { forall m: v. LM.mem m m_list -> LM.mem m (vertices_list g) }
    ensures   { forall m: v. LM.mem m m_list /\ is_metadata m -> LM.mem m result }
  = match m_list with
    | Nil -> Nil
    | Cons m r -> if is_metadata m
                    then Cons m (filter_metadata_parents r g)
                    else (filter_metadata_parents r g)
    end

  let function all_metadata_list (g: graph) : list v
    ensures { result = filter_metadata (vertices_list g) g }
  = filter_metadata (vertices_list g) g

  let rec function filter_metadata_from_list (l: list v) : list v
    ensures { forall m: v. LM.mem m result <-> LM.mem m l /\ is_metadata m }
    ensures { forall m: v. LM.mem m result -> is_metadata m }
  = match l with
    | Nil -> Nil
    | Cons x r ->
        if is_metadata x then Cons x (filter_metadata_from_list r) else filter_metadata_from_list r
    end

  let rec ghost function collect_reachable_metadata (worklist: list v) (visited: fset v) (g: graph) : fset v
  requires  { forall m: v. LM.mem m worklist -> is_metadata m /\ memv m g }
  requires  { forall m: v. mem m visited -> is_metadata m /\ memv m g }
  requires  { forall m: v. LM.mem m worklist -> mem m visited }
  variant   { cardinal g.vertices - cardinal visited, length worklist }
  ensures   { forall m: v. mem m result -> is_metadata m /\ memv m g }
  ensures   { subset visited result }
  = match worklist with
  | Nil -> visited
  | Cons current rest ->
      let old_card = cardinal visited in
      let old_vertices_card = cardinal g.vertices in
      let succ_list = successors_list current g in
      let metadata_succ = filter_metadata_from_list succ_list in
      assert { forall n: v. LM.mem n metadata_succ -> memv n g };
      let visited' = list_to_fset (fset_to_list visited ++ metadata_succ) in
      assert { cardinal g.vertices = old_vertices_card };
      assert { subset visited visited' };
      assert { is_nil metadata_succ \/ cardinal visited' > old_card };
      let worklist' = rest ++ metadata_succ in
      assert { is_nil metadata_succ -> length worklist' < length worklist };
      assert { not (is_nil metadata_succ) -> cardinal visited' > cardinal visited };
      assert { cardinal g.vertices - cardinal visited' < cardinal g.vertices - cardinal visited };
      assert { 
        cardinal g.vertices - cardinal visited' < cardinal g.vertices - cardinal visited /\
        length worklist' < length worklist 
      };
      collect_reachable_metadata worklist' visited' g
  end

  let ghost function get_metadata_tree (m: v) (g: graph) : graph
    requires  { is_metadata m /\ memv m g }
    ensures   { memv m result }
    ensures   { forall n: v. memv n result <-> (exists l: list v. metadata_path m l n g) }
  = let reachable = collect_reachable_metadata (Cons m Nil) (singleton m) g in
    let vertices = reachable in
    let edges = Fset.filter g.edges
      (fun (e: e) -> let (u, v) = e in mem u reachable && mem v reachable) in
    { vertices = vertices; edges = edges }

  let rec ghost function add_metadata_trees_from_list (l: list v) (g: graph) : graph
    requires  { forall m: v. LM.mem m l ->  is_metadata m /\ memv m g }
    ensures   { forall m: v. LM.mem m l -> (forall n: v. memv n (get_metadata_tree m g) -> memv n result) }
  = match l with
    | Nil -> g
    | Cons m r ->
        let metadata_tree = get_metadata_tree m g in
        graph_union metadata_tree (add_metadata_trees_from_list r g)
    end

  let ghost function get_whole_metadata_forest (g: graph) : graph
    ensures   { forall m n: v. LM.mem n (get_all_roots g) -> (memv m result <-> memv m (get_metadata_tree n g)) }
  = add_metadata_trees_from_list (get_all_roots g) g 

end