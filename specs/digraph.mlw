theory DiGraph

  use set.Fset
  use int.Int
  use list.List
  use list.Length
  use list.Mem as LM

  type v
  type e

  val function src (e: e) : v  
  val function dst (e: e) : v 

  type graph = { vertices: fset v; edges: fset e }

  predicate memv (v: v) (g: graph) =
    mem v g.vertices

  predicate meme (e: e) (g: graph) =
    mem e g.edges

  (* edge existence *)
  predicate edgep (g: graph) (v1 v2: v) =
    exists e: e. meme e g /\ src e = v1  /\ dst e = v2

  (* edges well formed *)
  axiom edges_well_formed: 
    forall v1 v2: v, e: e, g: graph. meme e g /\ src e = v1 /\ dst e = v2 <-> memv v1 g /\ memv v2 g

  (* Toy lemma to verify axiom works *)
  lemma vertex_existence:
    forall v1 v2: v, e: e, g: graph. memv v2 g /\ meme e g /\ src e = v1 /\ dst e = v2 -> memv v1 g
  
  predicate empty_edges (g: graph) = is_empty g.edges
  predicate empty_vertices (g: graph) = is_empty g.vertices
  predicate empty_graph (g: graph) = empty_edges g /\ empty_vertices g

  lemma empty_vertices_to_empty_edges:
    forall g: graph. empty_vertices g -> empty_edges g

  lemma cardinal_empty_edges:
    forall g: graph. empty_edges g -> cardinal g.edges = 0

  lemma cardinal_empty_vertices:
    forall g: graph. empty_vertices g -> cardinal g.vertices = 0

  lemma cardinal_empty_graph:
    forall g: graph. empty_graph g -> cardinal g.vertices = cardinal g.edges = 0 

  val function indegree (v: v) (g: graph) : int
    ensures { result = cardinal (Fset.filter g.edges (fun (p: e) -> dst p = v)) }
    ensures { 0 <= result }
    ensures { result <= cardinal g.edges }

  val function outdegree (v: v) (g: graph) : int
    ensures { result = cardinal (Fset.filter g.edges (fun (p: e) -> src p = v)) }
    ensures { 0 <= result }
    ensures { result <= cardinal g.edges }

  val function degree (v: v) (g: graph) : int
    ensures { result = indegree v g + outdegree v g }
    ensures { 0 <= result }
    ensures { result <= cardinal g.edges }

  (* basic operations *)
  val function insertv (v: v) (g: graph) : graph
    requires  { forall u:v. memv u g -> u <> v }
    ensures   { result.edges = g.edges }
    ensures   { result.vertices = Fset.add v g.vertices }

  lemma insertv_empty:
    forall g1 g2: graph, v: v. empty_graph g1 -> g2 = insertv v g1 -> memv v g2 /\ cardinal g2.vertices = 1

  lemma insertv_cardinal:
    forall g1 g2: graph, v: v.
      (g2 = insertv v g1 /\ forall u:v. memv u g1 -> u <> v) 
        -> memv v g2 /\ cardinal g2.vertices = cardinal g1.vertices + 1

  val function deletev (v: v) (g: graph) : graph
    ensures { result.vertices = Fset.remove v g.vertices }
    ensures { result.edges = Fset.filter g.edges (fun (p: e) -> src p <> v /\ dst p <> v) }
    ensures { degree v result = 0 }
    ensures { forall u: v. u <> v -> memv u g -> degree u g = degree u result }

  lemma deletev_cardinal_vertices:
    forall g1 g2: graph, v: v, n: int. 
      n = cardinal g1.vertices /\ 
      g2 = deletev v g1 
        -> cardinal g2.vertices = n \/ cardinal g2.vertices = n - 1

  lemma deletev_cardinal_edges:
    forall g1 g2: graph, v: v, n: int. 
      (n = cardinal g1.edges /\ 
      g2 = deletev v g1 /\
      memv v g1)
        -> cardinal g2.edges = n - (degree v g1) 

  val function inserte (e: e) (g: graph) : graph
    requires  { memv (src e) g /\ memv (dst e) g }
    requires  { forall f: e. meme f g -> f <> e }
    ensures   { result.vertices = g.vertices }
    ensures   { result.edges = Fset.add e g.edges }
  
  lemma inserte_cardinal_edges:
    forall g1 g2: graph, e: e, n: int. 
      (n = cardinal g1.edges /\ 
      g2 = inserte e g1 /\ 
      memv (src e) g1 /\ memv (dst e) g1 /\
      forall f: e. meme f g1 -> f <> e)
        -> meme e g2 /\ cardinal g2.edges = (n + 1)

  val function deletee (e: e) (g: graph) : graph
    ensures { result.edges = Fset.remove e g.edges }
    ensures { result.vertices = g.vertices }

  lemma deletee_cardinal_edges:
    forall g1 g2: graph, e: e, n: int. 
      n = cardinal g1.edges /\
      g2 = deletee e g1 
        -> cardinal g2.edges = n \/ cardinal g2.edges = (n-1)

  val function fset_to_list (s: fset 'a) : list 'a
    ensures { forall x: 'a. Fset.mem x s -> LM.mem x result }
    (*ensures { cardinal s = length result }*)
    ensures { forall x y: 'a. LM.mem x result /\ LM.mem y result -> x <> y }

  lemma empty_fset_to_list:
    forall s: fset 'a, l: list 'a.
      l = fset_to_list s /\
      is_empty s
        -> is_nil l

  lemma cardinal_eq_length:
    forall s: fset 'a, l: list 'a.
      l = fset_to_list s
        -> cardinal s = length l

  val function vertices_list (g: graph) : list v
    ensures { result = fset_to_list g.vertices }

  val function edges_list (g: graph) : list e
    ensures { result = fset_to_list g.edges }

  val function edgesv_set (v: v) (g: graph) : fset e
    ensures { result = Fset.filter g.edges (fun (p: e) -> src p = v \/ dst p = v)}

  lemma nb_edgesv_set:
    forall g: graph, v: v.
      cardinal (edgesv_set v g) = degree v g

  val function edgesv_list (v: v) (g: graph) : list e
    ensures { result = fset_to_list (Fset.filter g.edges (fun (p: e) -> src p = v \/ dst p = v))}

  lemma nb_edgesv_list:
    forall g: graph, v: v.
      length (edgesv_list v g) = degree v g  

  val function edges_srcv (v: v) (g: graph) : fset e
    ensures { result = Fset.filter g.edges (fun (p:e) -> src p = v) }

  val function successors (v: v) (g: graph) : fset v
    ensures { result = map (fun (p: e) -> src p) (edges_srcv v g) }

  val function successors_list (v: v) (g: graph) : list v
    ensures { result = fset_to_list (successors v g) }

  lemma members_successors:
    forall g: graph, v: v, succ: fset v. succ = successors v g ->
      (forall u: v. mem u succ <-> (exists e: e. meme e g /\ src e = v /\ dst e = u))

  val function edges_dstv (v: v) (g: graph) : fset e
    ensures { result = Fset.filter g.edges (fun (p:e) -> dst p = v) }

  val function predecessors (v: v) (g: graph) : fset v
    ensures { result = map (fun (p: e) -> dst p) (edges_dstv v g) }

  val function predecessors_list (v: v) (g: graph) : list v
    ensures { result = fset_to_list (predecessors v g) }

  lemma members_predecessors:
    forall g: graph, v: v, pred: fset v. pred = predecessors v g ->
      (forall u: v. mem v pred <-> (exists e: e. meme e g /\  src e = u /\ dst e = v) )

  (* Definizioni semplificate; le originali erano logicamente equivalenti a 'true' o 'memv'/'meme' *)
  predicate existsv (v: v) (g: graph) =
    memv v g

  lemma not_existsv_empty:
    forall g: graph, v: v. empty_graph g -> not (existsv v g)

  lemma insertv_exists:
    forall g1, g2: graph, v: v. g2 = insertv v g1 -> existsv v g2

  lemma deletev_not_exists:
    forall g1, g2: graph, v: v. g2 = deletev v g1 -> not (existsv v g2)

  predicate existse (e: e) (g: graph) =
    meme e g

  lemma not_existse_empty:
    forall g: graph, e: e. empty_graph g -> not (existse e g)

  lemma inserte_exists:
    forall g1, g2: graph, e: e. g2 = inserte e g1 -> existse e g2

  lemma deletee_not_exists:
    forall g1, g2: graph, e: e. g2 = deletee e g1 -> not (existse e g2)

  lemma deletev_not_existsev:
    forall g1, g2: graph, v, u: v.
      (forall e: e. (src e = v \/ src e = u \/ dst e = v \/ dst e = u)
         -> g2 = deletev u (deletev v g1)
          -> not (existsv v g2) /\ not (existsv u g2) /\ not (existse e g2) )

end